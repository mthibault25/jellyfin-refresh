<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Riven Media UI</title>
  <link rel="stylesheet" href="{{ url_for('static_files', filename='style.css') }}">
</head>
<body>
  <header>
    <h1>Riven Media — Remote UI</h1>
    <nav>
      <a href="{{ url_for('index') }}">Home</a>
    </nav>
  </header>

  <main>
    {% block content %}{% endblock %}
  </main>

  <footer>
    <small>Runs on {{ request.host }} — uses server scripts in /opt/docker/scripts</small>
  </footer>

  <script>
  // helper: stream command output and display inside a <pre> element
  async function streamToPre(url, form=null, preId='output') {
    const pre = document.getElementById(preId)
    pre.textContent = ''
    const options = { method: 'POST' }
    if (form) {
      options.body = new URLSearchParams(form)
      options.headers = { 'Content-Type': 'application/x-www-form-urlencoded' }
    }

    const resp = await fetch(url, options)
    if (!resp.ok) {
      pre.textContent = `Error: ${resp.status} ${resp.statusText}`
      return
    }

    if (!resp.body) {
      pre.textContent = await resp.text()
      return
    }

    const reader = resp.body.getReader()
    const decoder = new TextDecoder()
    try {
      while (true) {
        const {done, value} = await reader.read()
        if (done) break
        // decode streamed chunk and append
        pre.textContent += decoder.decode(value, { stream: true })
        pre.scrollTop = pre.scrollHeight
      }
      // flush any remaining partial characters
      pre.textContent += decoder.decode()
      pre.scrollTop = pre.scrollHeight
    } catch (err) {
      pre.textContent += `\n\n[stream error] ${err}`
    } finally {
      if (reader.releaseLock) try { reader.releaseLock() } catch(e) {}
    }
  }
  </script>
</body>
</html>
